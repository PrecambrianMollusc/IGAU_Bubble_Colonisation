<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="data:,">
  <meta charset="UTF-8" />
  <title>GLTF Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  //Import modules
  import * as THREE from './js/three.module.js';
  import { GLTFLoader } from './js/GLTFLoader.js';
  import { DRACOLoader } from './js/DRACOLoader.js';
  import { OrbitControls } from './js/OrbitControls.js';
 import GUI from './js/lil-gui.esm.js';   // ← this is the file you downloaded

  const loader = new GLTFLoader();
  const dracoLoader = new DRACOLoader();
  // Point this to the Draco decoder files (downloaded from three.js repo)
  //dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/'); 
  // or a local path like './draco/' if you host the decoder files yourself
  dracoLoader.setDecoderPath('./draco/'); 
  
  loader.setDRACOLoader(dracoLoader);
  // renderer , camera, scene, controls
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

// Camera
const aspect = window.innerWidth / window.innerHeight;
const camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 120000);

// Position the camera so it can see the scene
camera.position.set(500, 4000, 4000);
camera.lookAt(0, 0, 0);

  // Lighting section — right after camera
  
  const ambient = new THREE.AmbientLight(0xffffff, 0.9);
  scene.add(ambient);
  
  const hemi = new THREE.HemisphereLight(0x88ccff, 0x222244, 0.8);
  scene.add(hemi);
   
  const directional = new THREE.DirectionalLight(0xffffff, 0.8);
  directional.position.set(1, 1, 1);
  scene.add(directional);
    
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 0, 0);
  controls.update();

  // Handle resize
  window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  });

  console.log('Attempting to load GLTF...');
  
  // Functions and helpers
  

  // get the disc sprite 
  const sprite_sphere = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
  sprite_sphere.colorSpace = THREE.SRGBColorSpace; // ensures correct color rendering
  console.log('Sprite loaded:', sprite_sphere);

  // load the gtlf file 
  // const loader = new GLTFLoader();
  // set up list of files to load 
  const allegianceFiles = [
  { name: 'Empire',     url: './glbdata/vis_bubbleEmpire.gltf'},
  { name: 'Federation', url: './glbdata/vis_bubbleFederation.gltf'},
  { name: 'Alliance',   url: './glbdata/vis_bubbleAlliance.gltf'},
  { name: 'Independent',   url: './glbdata/vis_bubbleIndependent.gltf'},
  { name: 'IGAU',   url: './glbdata/vis_bubbleIGAU.gltf'},
  { name: 'Mikunn',   url: './glbdata/vis_bubbleMikunn.gltf'},
  { name: 'Guardian',   url: './glbdata/vis_bubbleGuardian.gltf'},
  { name: 'Thargoid',   url: './glbdata/vis_bubbleThargoid.gltf'},
];

const allegianceGroups = {}; // store loaded groups
let loadedCount = 0;

function applyPointMaterialSettings(group, sprite) {
  group.traverse((obj) => {
    if (obj.isPoints) {
      obj.material.map = sprite;
      obj.material.size = 5.0;
      obj.material.opacity = 0.5;
      obj.material.transparent = true;
      obj.material.depthWrite = false;
      obj.material.blending = THREE.AdditiveBlending;
      obj.material.emissiveIntensity = 0.5;
      obj.material.needsUpdate = true;
    }
  });
}

// preload all GLTFs
allegianceFiles.forEach(({ name, url}) => {
  loader.load(
    url,
    (gltf) => {
      console.log('Loaded', name, gltf);
     

      const group = new THREE.Group();
      group.add(gltf.scene);
      allegianceGroups[name] = group;
      scene.add(group);
      
      applyPointMaterialSettings(group, sprite_sphere);

      loadedCount++;
      if (loadedCount === allegianceFiles.length) {
        setupGUI(); // only once *all* are loaded
      }
    },
    undefined,
    (err) => console.error(`Error loading ${url}`, err)
  );
});


// add the galaxy G stars
const scale = 45000 / 32000; // same as Python
const center_gal = new THREE.Vector3(15918, -91, -1299); // from Python
  
loader.load('./star_cloud.glb', gltf => {
  const cloud = gltf.scene;
 console.log('GLTF loaded-: ', cloud);

  cloud.traverse(obj => {
    if (obj.isPoints) {
      const mat = obj.material;
      mat.color.set(0xffa500);       // orange
      mat.transparent = true;
      sizeAttenuation: true,
      mat.opacity = 0.03;              // low opacity
      mat.size = 0.15;                 // small point size
      mat.depthWrite = false;        // optional: improves blending
      
      mat.needsUpdate = true;
    }
  });
 
  scene.add(cloud);
});


// add the nebulas 
  const labels = {
      "NGC 133": [-954.0 ,-382.0, -397.0],
      "Orion Dark": [-1337, -312,603.0],
      "LBN 623 Nebula": [-332, -16,-499],
      "Witch Head Nebula": [-718 -385, 359],
      "California Nebula": [-927 -211, -337],
      "Barnards's Loop": [-1224 -421, 617],
      "Veil Nebula West": [418 ,-193, -1398],
      "Sadr": [356 ,53, -1794],
      "Pelican Nebula": [174 ,-1, -1886],
      "Coal Sack Nebula": [212, 43,501],
      "Lagoon Nebula": [ 4474,-92,-486],
      "Triffid Nebula": [5162,-26.3,-638]     
    };
      
  const nebulaMaterial = new THREE.MeshPhongMaterial({
    color: 0x9966ff,           // Ethereal violet
    transparent: true,
    opacity: 0.3,
    shininess: 80,
    emissive: 0x330066,
    emissiveIntensity: 0.5,
    });
      
  const createTextSprite = (text) => {
    const canvas = document.createElement('canvas');
    canvas.width = 512;  // Wider canvas for longer labels
    canvas.height = 128;

    const context = canvas.getContext('2d');
    context.font = 'Bold 48px Arial';
    context.fillStyle = 'rgba(255,255,255,0.8)';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(150, 50, 1); // Wider scale to match canvas
    return sprite;
  };


  Object.entries(labels).forEach(([name, pos]) => {
    // Ethereal sphere
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(40, 32, 32),
      new THREE.MeshPhongMaterial({
        color: 0x9966ff,
        transparent: true,
        opacity: 0.3,
        emissive: 0x330066,
        emissiveIntensity: 0.5,
      })
    );
    sphere.position.set(...pos);
    scene.add(sphere);

    // Sprite label
    const label = createTextSprite(name);
    label.position.set(pos[0], pos[1] + 60, pos[2]); // Offset above sphere
    scene.add(label);
  });



function setupGUI() {
  // Global Controls GUI (wide, top)
  const globalGUI = new GUI({ width: 500 });
  globalGUI.domElement.style.position = 'absolute';
  globalGUI.domElement.style.top = '10px';
  globalGUI.domElement.style.left = '10px';

  const state = { step: 40 };
  globalGUI.add(state, 'step', 1, 40, 1)
    .name('Visible Step')
    .onChange((val) => {
      Object.values(allegianceGroups).forEach((group) => {
        if (!group.visible) return;
        const meshes = [];
        group.traverse((obj) => { if (obj.isPoints) meshes.push(obj); });
        meshes.sort((a, b) => a.name.localeCompare(b.name));
        meshes.forEach((m, i) => {
          m.visible = (i === 0) || (i <= val);
        });
      });
    });

  // Allegiance Visibility GUI (narrow, shifted down)
  const allegianceGUI = new GUI();
  allegianceGUI.domElement.style.position = 'absolute';
  allegianceGUI.domElement.style.top = '120px'; // push it down below the slider
  allegianceGUI.domElement.style.left = '10px';

  Object.keys(allegianceGroups).forEach((name) => {
    const group = allegianceGroups[name];
    const folder = allegianceGUI.addFolder(name);
    folder.add(group, 'visible').name('Show/Hide');
  });
}


function animate() {
  requestAnimationFrame(animate);
  controls.update();

  const pos = camera.position;
  const tgt = controls.target;
  //info.textContent =
  //  `Camera: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}) ` +
  //  `Target: (${tgt.x.toFixed(1)}, ${tgt.y.toFixed(1)}, ${tgt.z.toFixed(1)})`;

  renderer.render(scene, camera);
}

  animate();
  
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>
</body>
</html>
